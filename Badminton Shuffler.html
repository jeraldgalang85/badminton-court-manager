<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Shuffler</title>
    <link rel="icon" type="image/png" href="North Smashers.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #344C3D 0%, #1a2620 100%);
            min-height: 100vh;
            padding: 20px;
            transition: background 0.3s ease;
        }

        body.dark-mode {
            background: linear-gradient(135deg, #0a0a0a 0%, #000000 100%);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Dark Mode Styles */
        body.dark-mode .container {
            background: #000000;
            color: #e0e0e0;
        }

        body.dark-mode h1 {
            color: #e0e0e0;
        }

        body.dark-mode .header-subtitle {
            color: #d4af37;
        }

        body.dark-mode .section-title {
            color: #d4af37;
        }

        body.dark-mode .player-column {
            background: #2a2a2a;
        }

        body.dark-mode .player-item {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .player-input-group input {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .config-group {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        body.dark-mode .config-group label {
            color: #e0e0e0;
        }

        body.dark-mode .config-group select,
        body.dark-mode .config-group input[type="number"] {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .round {
            background: #2a2a2a;
        }

        body.dark-mode .court {
            background: #333;
            border-color: #d4af37;
        }

        body.dark-mode .court-title {
            color: #d4af37;
        }

        body.dark-mode .team {
            background: #2a2a2a;
        }

        body.dark-mode .team-label {
            color: #e0e0e0;
        }

        body.dark-mode .regular-player-item {
            background: #333;
            border-color: #444;
        }

        body.dark-mode .regular-player-name {
            color: #e0e0e0;
        }

        body.dark-mode #regular-players-list {
            background: #2a2a2a;
        }

        /* Dark Mode Toggle Button */
        .dark-mode-toggle {
            position: absolute;
            top: 30px;
            right: 30px;
            background: #1a5632;
            color: #d4af37;
            border: 2px solid #d4af37;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.3s;
        }

        .dark-mode-toggle:hover {
            background: #0d3d1f;
            transform: scale(1.05);
        }

        /* Booking Links */
        .booking-links {
            position: absolute;
            top: 30px;
            right: 120px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: calc(100% - 200px);
        }

        .booking-btn {
            background: #1a5632;
            color: #d4af37;
            border: 2px solid #d4af37;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            text-decoration: none;
            transition: all 0.3s;
            display: inline-block;
            white-space: nowrap;
        }

        .booking-btn:hover {
            background: #0d3d1f;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(26, 86, 50, 0.4);
        }

        body.dark-mode .booking-btn {
            background: #2a2a2a;
            color: #d4af37;
            border-color: #d4af37;
        }

        body.dark-mode .booking-btn:hover {
            background: #1a5632;
        }

        @media (max-width: 768px) {
            .booking-links {
                position: static;
                margin: 15px auto;
                justify-content: center;
                max-width: 100%;
            }
            
            .dark-mode-toggle {
                position: static;
                margin: 10px auto 20px;
                display: block;
                width: fit-content;
            }
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .header-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .logo {
            max-width: 200px;
            width: 100%;
            height: auto;
        }

        .header-text {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .header-title {
            font-size: 3em;
            font-weight: bold;
            color: #d4af37;
            margin: 0;
            line-height: 1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header-subtitle {
            font-size: 1.2em;
            color: #1a5632;
            margin-top: 8px;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                text-align: center;
            }
            
            .header-title {
                font-size: 2em;
            }
            
            .header-subtitle {
                font-size: 1em;
            }
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.5em;
            color: #1a5632;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #d4af37;
        }

        /* Player Input Section */
        .player-columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .player-column {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ddd;
        }

        .player-column.beginner {
            border-color: #d4af37;
        }

        .player-column.intermediate {
            border-color: #d4af37;
        }

        .player-column.advanced {
            border-color: #d4af37;
        }

        .column-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            color: white;
            border: 3px solid #d4af37;
        }

        .beginner .column-header {
            background: #A8C5A3;
            color: #d4af37;
        }

        .intermediate .column-header {
            background: #738A6E;
            color: #d4af37;
        }

        .advanced .column-header {
            background: #344C3D;
            color: #d4af37;
        }

        .player-count {
            font-size: 0.9em;
            font-weight: normal;
            opacity: 0.9;
        }

        .player-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .player-input-group input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .player-input-group button {
            padding: 10px 15px;
            background: #344C3D;
            color: #d4af37;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .player-input-group button:hover {
            background: #2a3a2f;
        }

        .player-list {
            margin-top: 15px;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 5px;
            margin-bottom: 5px;
            border: 1px solid #ddd;
        }

        .player-item button {
            padding: 5px 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .player-item button:hover {
            background: #c82333;
        }

        /* Configuration Section */
        .config-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .config-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        /* Court Floor Plan Styles */
        .floor-plan-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .court-box {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #e9ecef;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            color: #999;
            position: relative;
            padding: 5px;
        }

        .court-box:hover {
            background: #dee2e6;
            transform: scale(1.05);
        }

        .court-box.selected {
            background: #1a5632;
            color: #d4af37;
            border-color: #d4af37;
        }

        .court-box.selected:hover {
            background: #0d3d1f;
        }

        .court-box .physical-num {
            font-size: 1.2em;
        }

        .court-box .sequence-num {
            font-size: 0.75em;
            margin-top: 2px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .court-box.selected .sequence-num {
            opacity: 1;
        }

        body.dark-mode .court-box {
            background: #444;
            border-color: #555;
            color: #888;
        }

        body.dark-mode .court-box.active {
            background: #1a5632;
            color: #d4af37;
            border-color: #d4af37;
        }

        .config-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        .config-group select,
        .config-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #1a5632;
        }

        input:checked + .slider:before {
            transform: translateX(30px);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #344C3D;
            color: #d4af37;
            border: 2px solid #d4af37;
        }

        .btn-primary:hover {
            background: #2a3a2f;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 76, 61, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        /* Results Section */
        .results {
            margin-top: 30px;
        }

        .round {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .round-header {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #1a5632;
        }

        .courts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .court {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #1a5632;
            position: relative;
        }

        .court-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #1a5632;
            font-size: 1.1em;
        }

        .team {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .team-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .player-name {
            padding: 3px 8px;
            border-radius: 3px;
            display: inline-block;
            margin: 2px;
            font-size: 0.9em;
        }

        .player-name.beginner {
            background: #A8C5A3;
            color: white;
        }

        .player-name.intermediate {
            background: #738A6E;
            color: white;
        }

        .player-name.advanced {
            background: #344C3D;
            color: white;
        }

        .vs {
            text-align: center;
            font-weight: bold;
            color: #d4af37;
            margin: 10px 0;
        }

        .score-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .score-inputs input {
            width: 60px;
            padding: 5px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .sitting-out {
            margin-top: 15px;
            padding: 10px;
            background: #fff3cd;
            border-radius: 5px;
            border: 1px solid #ffc107;
        }

        .sitting-out-label {
            font-weight: bold;
            color: #856404;
            margin-bottom: 5px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .hidden {
            display: none;
        }

        /* Player Swap Styles */
        .swap-btn {
            padding: 2px 6px;
            margin-left: 5px;
            background: #1a5632;
            color: #d4af37;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }

        .swap-btn:hover {
            background: #0d3d1f;
            transform: scale(1.05);
        }

        .player-name {
            cursor: grab;
            transition: all 0.2s;
        }

        .player-name:active {
            cursor: grabbing;
        }

        .player-name.swap-mode {
            border: 2px solid #d4af37;
            animation: pulse 1s infinite;
        }

        .player-name.swap-target {
            border: 2px dashed #28a745;
            cursor: pointer;
        }

        .player-name.swap-target:hover {
            background-color: #d4edda;
            border-color: #28a745;
            transform: scale(1.05);
        }

        .player-name.dragging {
            opacity: 0.5;
        }

        .player-name.drag-over {
            border: 2px solid #28a745;
            background-color: #d4edda;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.7);
            }
            50% {
                box-shadow: 0 0 0 5px rgba(212, 175, 55, 0);
            }
        }

        /* Regular Players Styles */
        .star-selector {
            font-size: 1.5em;
            cursor: pointer;
            opacity: 0.3;
            transition: opacity 0.2s;
        }

        .star-selector.active {
            opacity: 1;
        }

        .star-selector:hover {
            opacity: 0.8;
        }

        .regular-player-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            margin-bottom: 5px;
            border: 1px solid #ddd;
        }

        .regular-player-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .regular-player-name {
            flex: 1;
            font-weight: 500;
        }

        .regular-player-stars {
            display: flex;
            gap: 2px;
            cursor: pointer;
        }

        .regular-player-stars span {
            font-size: 1.2em;
        }

        .regular-remove-btn {
            padding: 5px 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .regular-remove-btn:hover {
            background: #c82333;
        }

        @media print {
            body {
                background: white;
            }
            .container {
                box-shadow: none;
            }
            .section:not(.results) {
                display: none;
            }
            .action-buttons {
                display: none;
            }
            .print-court-btn {
                display: none;
            }
            .round-header {
                page-break-before: always;
            }
            .round-header:first-of-type {
                page-break-before: avoid;
            }
            .court {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="booking-links">
            <a href="https://badmintonnearme.yepbooking.com.au/" target="_blank" class="booking-btn">üìÖ Badminton Near Me</a>
            <a href="https://heidelbergbc.yepbooking.com.au/" target="_blank" class="booking-btn">üìÖ Heidelberg BC</a>
        </div>
        <button class="dark-mode-toggle" onclick="toggleDarkMode()" id="dark-mode-toggle">üåô</button>
        <div class="header-container">
            <img src="North Smashers.png" alt="North Smasher Logo" class="logo" onerror="this.onerror=null; this.src='North Smashers.jpg';">
            <div class="header-text">
                <div class="header-title">Badminton Shuffler</div>
                <div class="header-subtitle">Fair Teams, Better Games</div>
            </div>
        </div>

        <!-- Player Input Section -->
        <div class="section">
            <div class="section-title">
                Enter Players <span style="font-size: 0.8em; color: #999; font-weight: normal;" id="total-players">(Total: 0)</span>
                <button onclick="togglePlayerSection()" style="float: right; padding: 5px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.8em;">Hide/Show</button>
            </div>
            <div class="player-columns" id="player-columns-section">
                <div class="player-column beginner">
                    <div class="column-header">Beginner <span class="player-count" id="beginner-count">(0)</span></div>
                    <div class="player-input-group">
                        <input type="text" id="beginner-input" placeholder="Enter player name">
                        <button onclick="addPlayer('beginner')">Add</button>
                    </div>
                    <div class="player-list" id="beginner-list"></div>
                </div>

                <div class="player-column intermediate">
                    <div class="column-header">Intermediate <span class="player-count" id="intermediate-count">(0)</span></div>
                    <div class="player-input-group">
                        <input type="text" id="intermediate-input" placeholder="Enter player name">
                        <button onclick="addPlayer('intermediate')">Add</button>
                    </div>
                    <div class="player-list" id="intermediate-list"></div>
                </div>

                <div class="player-column advanced">
                    <div class="column-header">Advanced <span class="player-count" id="advanced-count">(0)</span></div>
                    <div class="player-input-group">
                        <input type="text" id="advanced-input" placeholder="Enter player name">
                        <button onclick="addPlayer('advanced')">Add</button>
                    </div>
                    <div class="player-list" id="advanced-list"></div>
                </div>
            </div>
        </div>

        <!-- Regular Players Section -->
        <div class="section">
            <div class="section-title">
                Regular Players
                <button onclick="toggleRegularSection()" style="float: right; padding: 5px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.8em;">Hide/Show</button>
            </div>
            
            <!-- Add New Regular Player -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                    <input type="text" id="new-regular-name" placeholder="Enter player name" style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                    <div id="new-regular-stars" style="display: flex; gap: 5px;">
                        <span class="star-selector" data-level="1" onclick="selectNewRegularLevel(1)">‚≠ê</span>
                        <span class="star-selector" data-level="2" onclick="selectNewRegularLevel(2)">‚≠ê</span>
                        <span class="star-selector" data-level="3" onclick="selectNewRegularLevel(3)">‚≠ê</span>
                    </div>
                    <button onclick="addRegularPlayer()" style="padding: 10px 20px; background: #344C3D; color: #d4af37; border: 2px solid #d4af37; border-radius: 5px; cursor: pointer; font-weight: bold;">Add</button>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="loadRegularPlayers()" class="btn btn-primary" style="flex: 1; padding: 10px;">Load Regular Players</button>
                    <button onclick="selectAllRegulars()" class="btn btn-primary" style="flex: 1; padding: 10px;">Select All</button>
                    <button onclick="autoPopulatePlayers()" class="btn btn-primary" style="flex: 1; padding: 10px;">Auto-Populate Selected</button>
                </div>
            </div>
            
            <!-- Regular Players List -->
            <div id="regular-players-section">
                <div id="regular-players-list" style="background: #f8f9fa; padding: 20px; border-radius: 10px; max-height: 400px; overflow-y: auto;">
                    <!-- Regular players will be listed here -->
                </div>
            </div>
        </div>

        <!-- Configuration Section -->
        <div class="section">
            <div class="section-title">Game Configuration</div>
            <div class="config-options">
                <div class="config-group">
                    <label for="game-type">Game Type:</label>
                    <select id="game-type">
                        <option value="level">Level Game (Same skill levels)</option>
                        <option value="mix">Mix Game (Mixed skill levels)</option>
                    </select>
                </div>

                <div class="config-group">
                    <label for="court-count">Number of Courts:</label>
                    <input type="number" id="court-count" min="1" max="10" value="2">
                    <small style="display: block; margin-top: 5px; color: #666;">Or leave it to auto-suggest based on player count</small>
                </div>

                <div class="config-group">
                    <label>Score Tracking:</label>
                    <div class="toggle-group">
                        <span>Off</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="score-tracking">
                            <span class="slider"></span>
                        </label>
                        <span>On</span>
                    </div>
                </div>

                <div class="config-group">
                    <label>Court Floor Plan: <small style="font-weight: normal; color: #666;">(Click to select courts in order)</small></label>
                    <div class="floor-plan-grid" id="floor-plan-grid">
                        <div class="court-box" data-physical="10" onclick="toggleCourtSelection(10)">
                            <div class="physical-num">10</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="11" onclick="toggleCourtSelection(11)">
                            <div class="physical-num">11</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="12" onclick="toggleCourtSelection(12)">
                            <div class="physical-num">12</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="7" onclick="toggleCourtSelection(7)">
                            <div class="physical-num">7</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="8" onclick="toggleCourtSelection(8)">
                            <div class="physical-num">8</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="9" onclick="toggleCourtSelection(9)">
                            <div class="physical-num">9</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="4" onclick="toggleCourtSelection(4)">
                            <div class="physical-num">4</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="5" onclick="toggleCourtSelection(5)">
                            <div class="physical-num">5</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="6" onclick="toggleCourtSelection(6)">
                            <div class="physical-num">6</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="1" onclick="toggleCourtSelection(1)">
                            <div class="physical-num">1</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="2" onclick="toggleCourtSelection(2)">
                            <div class="physical-num">2</div>
                            <div class="sequence-num">C1</div>
                        </div>
                        <div class="court-box" data-physical="3" onclick="toggleCourtSelection(3)">
                            <div class="physical-num">3</div>
                            <div class="sequence-num">C1</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button class="btn btn-primary" onclick="generateGames()">Generate Teams</button>
            <button class="btn btn-secondary" onclick="resetAll()">Reset</button>
        </div>

        <!-- Results Section -->
        <div class="section results hidden" id="results-section">
            <div class="section-title">
                Match Schedule
                <button onclick="printAllCourts()" style="float: right; padding: 10px 20px; background: #344C3D; color: #d4af37; border: 2px solid #d4af37; border-radius: 5px; cursor: pointer; font-weight: bold;">üñ®Ô∏è Print Schedule</button>
            </div>
            <div id="results-container"></div>
        </div>
    </div>

    <script>
        // Player data structure
        const players = {
            beginner: [],
            intermediate: [],
            advanced: []
        };

        // Add player to a skill level
        function addPlayer(level) {
            const input = document.getElementById(`${level}-input`);
            const name = input.value.trim();
            
            if (name) {
                players[level].push(name);
                input.value = '';
                renderPlayers(level);
            }
        }

        // Remove player from a skill level
        function removePlayer(level, index) {
            players[level].splice(index, 1);
            renderPlayers(level);
        }

        // Render player list for a skill level
        function renderPlayers(level) {
            const list = document.getElementById(`${level}-list`);
            const countSpan = document.getElementById(`${level}-count`);
            
            list.innerHTML = '';
            
            players[level].forEach((name, index) => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <span>${name}</span>
                    <button onclick="removePlayer('${level}', ${index})">Remove</button>
                `;
                list.appendChild(item);
            });
            
            // Update player count
            if (countSpan) {
                countSpan.textContent = `(${players[level].length})`;
            }
            
            // Update total player count
            updateTotalCount();
        }
        
        // Update total player count
        function updateTotalCount() {
            const totalSpan = document.getElementById('total-players');
            if (totalSpan) {
                const total = players.beginner.length + players.intermediate.length + players.advanced.length;
                totalSpan.textContent = `(Total: ${total})`;
            }
        }

        // Enable Enter key to add players
        ['beginner', 'intermediate', 'advanced'].forEach(level => {
            document.getElementById(`${level}-input`).addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addPlayer(level);
                }
            });
        });

        // Shuffle array utility
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Generate teams for Level Game with smart mixing
        function generateLevelGame(courtCount) {
            const allPlayers = [];
            
            // Skill level weights for balancing mixed games
            const skillWeights = {
                beginner: 1,
                intermediate: 2,
                advanced: 3
            };
            
            // Create player objects with skill level
            Object.keys(players).forEach(level => {
                players[level].forEach(name => {
                    allPlayers.push({ 
                        name, 
                        level,
                        weight: skillWeights[level]
                    });
                });
            });

            if (allPlayers.length < 4) {
                alert('Need at least 4 players to start a game!');
                return null;
            }

            const shuffled = shuffleArray(allPlayers);
            const rounds = [];
            const playersPerRound = courtCount * 4;
            
            // Generate multiple rounds
            let playerPool = [...shuffled];
            let roundNum = 1;
            
            while (playerPool.length >= 4) {
                const round = {
                    number: roundNum,
                    courts: [],
                    sittingOut: []
                };

                const playingThisRound = playerPool.slice(0, Math.min(playersPerRound, playerPool.length));
                const remaining = playerPool.slice(playingThisRound.length);

                // Group by skill level
                const grouped = {
                    beginner: [],
                    intermediate: [],
                    advanced: []
                };

                playingThisRound.forEach(p => grouped[p.level].push(p));

                // Create courts ordered by skill level: Advanced (Court 1), Intermediate (Court 2), Beginner (Court 3+)
                const leftoverPlayers = [];
                const courtAssignments = [];
                
                // Process in order: advanced, intermediate, beginner
                const levelOrder = ['advanced', 'intermediate', 'beginner'];
                
                levelOrder.forEach(level => {
                    const levelPlayers = shuffleArray(grouped[level]);
                    
                    // Create as many same-level courts as possible for this skill level
                    for (let i = 0; i + 3 < levelPlayers.length; i += 4) {
                        courtAssignments.push({
                            level: level,
                            team1: [levelPlayers[i], levelPlayers[i + 1]],
                            team2: [levelPlayers[i + 2], levelPlayers[i + 3]]
                        });
                    }

                    // Add leftover players (those who couldn't form a same-level game)
                    const leftover = levelPlayers.length % 4;
                    if (leftover > 0) {
                        leftoverPlayers.push(...levelPlayers.slice(-leftover));
                    }
                });
                
                // Assign court numbers to the created games (up to courtCount)
                let courtNum = 1;
                courtAssignments.slice(0, courtCount).forEach(assignment => {
                    round.courts.push({
                        number: courtNum,
                        team1: assignment.team1,
                        team2: assignment.team2
                    });
                    courtNum++;
                });
                
                // If we had more games than courts, add those players to leftover
                if (courtAssignments.length > courtCount) {
                    courtAssignments.slice(courtCount).forEach(assignment => {
                        leftoverPlayers.push(...assignment.team1, ...assignment.team2);
                    });
                }

                // If we still have available courts and enough leftover players, create mixed games
                // FORCE ALL COURTS TO BE USED - be super aggressive
                while (courtNum <= courtCount && leftoverPlayers.length >= 4) {
                    const mixedCourt = balanceTeamsForCourt(leftoverPlayers, courtNum);
                    if (mixedCourt) {
                        round.courts.push(mixedCourt);
                        courtNum++;
                    } else {
                        // If balanceTeamsForCourt fails, force create a court with ANY valid combination
                        // This should NEVER happen with our new aggressive function, but just in case
                        console.log('WARNING: Could not create valid court, forcing...');
                        break;
                    }
                }

                // Remaining leftover players sit out
                round.sittingOut = [...leftoverPlayers, ...remaining];
                rounds.push(round);

                // Rotate players for next round
                playerPool = [...remaining, ...playingThisRound];
                roundNum++;

                if (roundNum > 5) break; // Limit to 5 rounds
            }

            return rounds;
        }

        // Generate teams for Mix Game with skill balancing
        function generateMixGame(courtCount) {
            const allPlayers = [];
            
            // Skill level weights for balancing
            const skillWeights = {
                beginner: 1,
                intermediate: 2,
                advanced: 3
            };
            
            Object.keys(players).forEach(level => {
                players[level].forEach(name => {
                    allPlayers.push({ 
                        name, 
                        level,
                        weight: skillWeights[level]
                    });
                });
            });

            if (allPlayers.length < 4) {
                alert('Need at least 4 players to start a game!');
                return null;
            }

            const shuffled = shuffleArray(allPlayers);
            const rounds = [];
            const playersPerRound = courtCount * 4;
            
            let playerPool = [...shuffled];
            let roundNum = 1;
            
            while (playerPool.length >= 4) {
                const round = {
                    number: roundNum,
                    courts: [],
                    sittingOut: []
                };

                const playingThisRound = playerPool.slice(0, Math.min(playersPerRound, playerPool.length));
                const remaining = playerPool.slice(playingThisRound.length);

                // Create balanced teams
                const balancedCourts = createBalancedTeams(playingThisRound, courtCount);
                round.courts = balancedCourts;

                // Handle leftover players
                const usedPlayers = round.courts.length * 4;
                const leftoverFromPlaying = playingThisRound.slice(usedPlayers);
                round.sittingOut = [...leftoverFromPlaying, ...remaining];
                
                rounds.push(round);

                // Rotate for next round
                playerPool = [...remaining, ...playingThisRound];
                roundNum++;

                if (roundNum > 5) break; // Limit to 5 rounds
            }

            return rounds;
        }

        // Helper function to create truly mixed teams (better distribution for all levels)
        function createBalancedTeams(availablePlayers, courtCount) {
            const courts = [];
            
            // Group players by skill level
            const grouped = {
                advanced: [],
                intermediate: [],
                beginner: []
            };
            
            availablePlayers.forEach(p => {
                grouped[p.level].push(p);
            });
            
            // Shuffle each group
            grouped.advanced = shuffleArray(grouped.advanced);
            grouped.intermediate = shuffleArray(grouped.intermediate);
            grouped.beginner = shuffleArray(grouped.beginner);
            
            // Create a pool of all players to distribute evenly
            const allPlayersList = [];
            
            // Interleave players from different skill levels for better mixing
            const maxLength = Math.max(grouped.advanced.length, grouped.intermediate.length, grouped.beginner.length);
            
            for (let i = 0; i < maxLength; i++) {
                if (i < grouped.advanced.length) allPlayersList.push(grouped.advanced[i]);
                if (i < grouped.intermediate.length) allPlayersList.push(grouped.intermediate[i]);
                if (i < grouped.beginner.length) allPlayersList.push(grouped.beginner[i]);
            }
            
            // Now create teams from interleaved list, ensuring variety
            for (let courtNum = 1; courtNum <= courtCount; courtNum++) {
                if (allPlayersList.length < 4) break;
                
                const team1 = [];
                const team2 = [];
                
                // Pick 4 players and try to distribute them to create mixed teams
                const fourPlayers = allPlayersList.splice(0, 4);
                
                if (fourPlayers.length < 4) break;
                
                // Sort these 4 by level to help with pairing
                fourPlayers.sort((a, b) => b.weight - a.weight);
                
                // Strategy: Pair highest with lowest for balanced teams
                // Player distribution: [Highest, High, Low, Lowest]
                // Team 1: Highest + Lowest
                // Team 2: High + Low
                team1.push(fourPlayers[0]); // Highest
                team1.push(fourPlayers[3]); // Lowest
                team2.push(fourPlayers[1]); // High
                team2.push(fourPlayers[2]); // Low
                
                courts.push({
                    number: courtNum,
                    team1: team1,
                    team2: team2
                });
            }
            
            return courts;
        }

        // Create a balanced court assignment - AGGRESSIVE mode to fill ALL courts
        function balanceTeamsForCourt(players, courtNum) {
            if (players.length < 4) return null;
            
            // Shuffle players to randomize selection
            const shuffledPlayers = shuffleArray([...players]);
            
            // Group by skill level
            const grouped = {
                advanced: shuffledPlayers.filter(p => p.level === 'advanced'),
                intermediate: shuffledPlayers.filter(p => p.level === 'intermediate'),
                beginner: shuffledPlayers.filter(p => p.level === 'beginner')
            };
            
            // Rule: Advanced CANNOT play with Beginner
            // Valid combinations: Adv+Adv, Adv+Int, Int+Int, Int+Beg, Beg+Beg
            
            let team1 = [];
            let team2 = [];
            
            // Try all possible valid combinations until we find one that works
            const strategies = [
                // Pure level games (best)
                () => {
                    if (grouped.advanced.length >= 4) {
                        team1 = [grouped.advanced[0], grouped.advanced[1]];
                        team2 = [grouped.advanced[2], grouped.advanced[3]];
                        return true;
                    }
                    return false;
                },
                () => {
                    if (grouped.intermediate.length >= 4) {
                        team1 = [grouped.intermediate[0], grouped.intermediate[1]];
                        team2 = [grouped.intermediate[2], grouped.intermediate[3]];
                        return true;
                    }
                    return false;
                },
                () => {
                    if (grouped.beginner.length >= 4) {
                        team1 = [grouped.beginner[0], grouped.beginner[1]];
                        team2 = [grouped.beginner[2], grouped.beginner[3]];
                        return true;
                    }
                    return false;
                },
                // Mixed: Adv+Int teams
                () => {
                    if (grouped.advanced.length >= 2 && grouped.intermediate.length >= 2) {
                        team1 = [grouped.advanced[0], grouped.intermediate[0]];
                        team2 = [grouped.advanced[1], grouped.intermediate[1]];
                        return true;
                    }
                    return false;
                },
                () => {
                    if (grouped.advanced.length >= 1 && grouped.intermediate.length >= 3) {
                        team1 = [grouped.advanced[0], grouped.intermediate[0]];
                        team2 = [grouped.intermediate[1], grouped.intermediate[2]];
                        return true;
                    }
                    return false;
                },
                // Mixed: Int+Beg teams
                () => {
                    if (grouped.intermediate.length >= 2 && grouped.beginner.length >= 2) {
                        team1 = [grouped.intermediate[0], grouped.beginner[0]];
                        team2 = [grouped.intermediate[1], grouped.beginner[1]];
                        return true;
                    }
                    return false;
                },
                () => {
                    if (grouped.intermediate.length >= 3 && grouped.beginner.length >= 1) {
                        team1 = [grouped.intermediate[0], grouped.intermediate[1]];
                        team2 = [grouped.intermediate[2], grouped.beginner[0]];
                        return true;
                    }
                    return false;
                },
                // Mixed: Adv+Int vs Int+Beg
                () => {
                    if (grouped.advanced.length >= 1 && grouped.intermediate.length >= 2 && grouped.beginner.length >= 1) {
                        team1 = [grouped.advanced[0], grouped.intermediate[0]];
                        team2 = [grouped.intermediate[1], grouped.beginner[0]];
                        return true;
                    }
                    return false;
                },
                // Any 2 Advanced
                () => {
                    if (grouped.advanced.length >= 2) {
                        team1 = [grouped.advanced[0], grouped.advanced[1]];
                        // Fill team2 with any non-beginner if advanced, or any if no advanced in team2
                        const remaining = [...grouped.intermediate, ...grouped.beginner];
                        if (remaining.length >= 2) {
                            team2 = [remaining[0], remaining[1]];
                            return true;
                        }
                    }
                    return false;
                },
                // Any 2 Intermediate
                () => {
                    if (grouped.intermediate.length >= 2) {
                        team1 = [grouped.intermediate[0], grouped.intermediate[1]];
                        const remaining = [...grouped.advanced, ...grouped.beginner];
                        if (remaining.length >= 2) {
                            team2 = [remaining[0], remaining[1]];
                            // Check if team2 is valid (no Adv+Beg)
                            const hasAdv = team2.some(p => p.level === 'advanced');
                            const hasBeg = team2.some(p => p.level === 'beginner');
                            if (hasAdv && hasBeg) return false;
                            return true;
                        }
                    }
                    return false;
                },
                // Any 2 Beginners
                () => {
                    if (grouped.beginner.length >= 2) {
                        team1 = [grouped.beginner[0], grouped.beginner[1]];
                        const remaining = [...grouped.advanced, ...grouped.intermediate];
                        if (remaining.length >= 2) {
                            team2 = [remaining[0], remaining[1]];
                            return true;
                        }
                    }
                    return false;
                },
                // Last resort: any 4 players that can form valid teams
                () => {
                    const all = [...grouped.advanced, ...grouped.intermediate, ...grouped.beginner];
                    if (all.length >= 4) {
                        // Try to pick 4 that don't have Adv+Beg in same team
                        for (let i = 0; i < all.length - 3; i++) {
                            for (let j = i + 1; j < all.length - 2; j++) {
                                for (let k = j + 1; k < all.length - 1; k++) {
                                    for (let l = k + 1; l < all.length; l++) {
                                        const t1 = [all[i], all[j]];
                                        const t2 = [all[k], all[l]];
                                        
                                        const t1HasAdv = t1.some(p => p.level === 'advanced');
                                        const t1HasBeg = t1.some(p => p.level === 'beginner');
                                        const t2HasAdv = t2.some(p => p.level === 'advanced');
                                        const t2HasBeg = t2.some(p => p.level === 'beginner');
                                        
                                        if (!(t1HasAdv && t1HasBeg) && !(t2HasAdv && t2HasBeg)) {
                                            team1 = t1;
                                            team2 = t2;
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }
            ];
            
            // Try each strategy until one works
            for (const strategy of strategies) {
                if (strategy()) {
                    // Remove used players from original array
                    team1.forEach(p => {
                        const idx = players.findIndex(player => player.name === p.name && player.level === p.level);
                        if (idx !== -1) players.splice(idx, 1);
                    });
                    team2.forEach(p => {
                        const idx = players.findIndex(player => player.name === p.name && player.level === p.level);
                        if (idx !== -1) players.splice(idx, 1);
                    });
                    
                    return {
                        number: courtNum,
                        team1: team1,
                        team2: team2
                    };
                }
            }
            
            // Should never reach here if we have 4+ players
            return null;
        }

        // Generate games
        function generateGames() {
            const gameType = document.getElementById('game-type').value;
            const courtCount = parseInt(document.getElementById('court-count').value);

            // Count total players
            const totalPlayers = players.beginner.length + players.intermediate.length + players.advanced.length;

            if (totalPlayers < 4) {
                alert('Please add at least 4 players to start!');
                return;
            }

            // Auto-suggest courts if needed
            const suggestedCourts = Math.max(1, Math.floor(totalPlayers / 4));
            const courtsToUse = courtCount || suggestedCourts;

            // Store current game type for printing
            currentGameType = gameType;

            let rounds;
            if (gameType === 'level') {
                rounds = generateLevelGame(courtsToUse);
            } else {
                rounds = generateMixGame(courtsToUse);
            }

            if (rounds) {
                displayResults(rounds);
                updateFloorPlan(rounds);
            }
        }

        // Update floor plan to highlight active courts
        function updateFloorPlan(rounds) {
            // Find all unique court numbers used in the generated rounds
            const activeCourts = new Set();
            rounds.forEach(round => {
                round.courts.forEach(court => {
                    activeCourts.add(court.number);
                });
            });

            // Update all court boxes
            document.querySelectorAll('.court-box').forEach(box => {
                const courtNum = parseInt(box.dataset.court);
                if (activeCourts.has(courtNum)) {
                    box.classList.add('active');
                } else {
                    box.classList.remove('active');
                }
            });
        }

        // Jump to specific court's schedule when clicked
        function jumpToCourt(courtNum) {
            // Check if results are generated
            if (generatedRounds.length === 0) {
                alert('Please generate teams first to see court schedules!');
                return;
            }

            // Find the first round that has this court
            let found = false;
            for (let i = 0; i < generatedRounds.length; i++) {
                const round = generatedRounds[i];
                const court = round.courts.find(c => c.number === courtNum);
                if (court) {
                    // Scroll to this court
                    const courtElement = document.getElementById(`round-${round.number}-court-${courtNum}`);
                    if (courtElement) {
                        courtElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Add a highlight effect
                        courtElement.style.boxShadow = '0 0 20px rgba(212, 175, 55, 0.8)';
                        setTimeout(() => {
                            courtElement.style.boxShadow = '';
                        }, 2000);
                        found = true;
                        break;
                    }
                }
            }

            if (!found) {
                alert(`Court ${courtNum} is not being used in the current game configuration.`);
            }
        }

        // Display results
        function displayResults(rounds) {
            // Store rounds globally for printing
            generatedRounds = rounds;
            
            const container = document.getElementById('results-container');
            const scoreTracking = document.getElementById('score-tracking').checked;
            
            container.innerHTML = '';

            rounds.forEach(round => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'round';
                
                let html = `<div class="round-header">Round ${round.number}</div>`;
                
                if (round.courts.length === 0) {
                    html += '<div class="alert alert-warning">Not enough players for this round</div>';
                } else {
                    html += '<div class="courts-grid">';
                    
                    round.courts.forEach(court => {
                        const physicalCourt = getPhysicalCourtNumber(court.number);
                        const courtLabel = selectedCourts.length > 0 ? `Court ${court.number} (Physical: ${physicalCourt})` : `Court ${court.number}`;
                        html += `
                            <div class="court" id="round-${round.number}-court-${court.number}">
                                <div class="court-title">${courtLabel}</div>
                                <div class="team">
                                    <div class="team-label">Team 1:</div>
                                    ${court.team1.map((p, idx) => `
                                        <span class="player-name ${p.level}" 
                                              draggable="true" 
                                              data-round="${round.number}" 
                                              data-court="${court.number}" 
                                              data-team="1" 
                                              data-index="${idx}"
                                              ondragstart="handleDragStart(event)" 
                                              ondragover="handleDragOver(event)" 
                                              ondrop="handleDrop(event)" 
                                              ondragend="handleDragEnd(event)">${p.name}<button class="swap-btn" onclick="startSwap(${round.number}, ${court.number}, 1, ${idx})">‚ÜîÔ∏è</button></span>
                                    `).join('')}
                                </div>
                                <div class="vs">VS</div>
                                <div class="team">
                                    <div class="team-label">Team 2:</div>
                                    ${court.team2.map((p, idx) => `
                                        <span class="player-name ${p.level}" 
                                              draggable="true" 
                                              data-round="${round.number}" 
                                              data-court="${court.number}" 
                                              data-team="2" 
                                              data-index="${idx}"
                                              ondragstart="handleDragStart(event)" 
                                              ondragover="handleDragOver(event)" 
                                              ondrop="handleDrop(event)" 
                                              ondragend="handleDragEnd(event)">${p.name}<button class="swap-btn" onclick="startSwap(${round.number}, ${court.number}, 2, ${idx})">‚ÜîÔ∏è</button></span>
                                    `).join('')}
                                </div>
                                ${scoreTracking ? `
                                    <div class="score-inputs">
                                        <input type="number" min="0" placeholder="Team 1">
                                        <span>-</span>
                                        <input type="number" min="0" placeholder="Team 2">
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }

                if (round.sittingOut.length > 0) {
                    html += `
                        <div class="sitting-out" id="sitting-out-round-${round.number}">
                            <div class="sitting-out-label">Sitting Out:</div>
                            ${round.sittingOut.map((p, idx) => `
                                <span class="player-name ${p.level}" 
                                      draggable="true" 
                                      data-round="${round.number}" 
                                      data-sitting="true" 
                                      data-index="${idx}"
                                      ondragstart="handleDragStart(event)" 
                                      ondragover="handleDragOver(event)" 
                                      ondrop="handleDrop(event)" 
                                      ondragend="handleDragEnd(event)">${p.name}<button class="swap-btn" onclick="startSwapFromSitting(${round.number}, ${idx})">‚ÜîÔ∏è</button></span>
                            `).join('')}
                        </div>
                    `;
                }

                roundDiv.innerHTML = html;
                container.appendChild(roundDiv);
            });

            document.getElementById('results-section').classList.remove('hidden');
            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        }

        // Reset everything
        function resetAll() {
            if (confirm('Are you sure you want to reset everything?')) {
                players.beginner = [];
                players.intermediate = [];
                players.advanced = [];
                
                ['beginner', 'intermediate', 'advanced'].forEach(level => {
                    renderPlayers(level);
                });
                
                document.getElementById('results-section').classList.add('hidden');
                document.getElementById('results-container').innerHTML = '';
            }
        }

        // ===== REGULAR PLAYERS FUNCTIONALITY =====
        
        let regularPlayers = [];
        let newRegularStarLevel = 2; // Default to intermediate

        // Predefined regular players list
        const defaultRegularPlayers = [
            "Allan Dale Ho",
            "Allyza Magsino Ramos",
            "Amir Acosta",
            "Ian Evangelista",
            "Chesca Chua-Vivas",
            "Dianne Miles Ho",
            "Dyan Galang",
            "Earl Angkiko",
            "Edz Verduz",
            "Gemma Dulguime",
            "Gian Verduz",
            "Isabel Cabucana",
            "Jay-ar Ramos",
            "Jerald Galang",
            "Lester Cabucana",
            "Luzsil Ledesma",
            "Micheal Chavez",
            "Michael Asterpix",
            "Michael Magpantay",
            "Mok Vivas",
            "Pjay Lagura",
            "Vonnet Estaris",
            "Zoe Chow"
        ];

        // Select star level for new regular player
        function selectNewRegularLevel(level) {
            newRegularStarLevel = level;
            updateNewRegularStars();
        }

        // Update star display for new regular player input
        function updateNewRegularStars() {
            const stars = document.querySelectorAll('#new-regular-stars .star-selector');
            stars.forEach((star, index) => {
                if (index < newRegularStarLevel) {
                    star.classList.add('active');
                } else {
                    star.classList.remove('active');
                }
            });
        }

        // Add a new regular player
        function addRegularPlayer() {
            const input = document.getElementById('new-regular-name');
            const name = input.value.trim();
            
            if (name) {
                regularPlayers.push({
                    name: name,
                    level: newRegularStarLevel,
                    checked: false
                });
                input.value = '';
                newRegularStarLevel = 2; // Reset to intermediate
                updateNewRegularStars();
                renderRegularPlayers();
                saveRegularPlayers(); // Save the entire list including custom players
            }
        }

        // Load predefined regular players
        function loadRegularPlayers() {
            if (regularPlayers.length > 0) {
                if (!confirm('This will replace current regular players list. Continue?')) {
                    return;
                }
            }
            
            // Try to load saved ratings from localStorage
            const savedRatings = loadSavedRatings();
            
            regularPlayers = defaultRegularPlayers.map(name => ({
                name: name,
                level: savedRatings[name] || 2, // Use saved level or default to intermediate
                checked: false
            }));
            
            renderRegularPlayers();
            saveRatings(); // Save immediately
        }

        // Remove a regular player
        function removeRegularPlayer(index) {
            regularPlayers.splice(index, 1);
            renderRegularPlayers();
            saveRegularPlayers(); // Save after removing
        }

        // Toggle player star level
        function toggleRegularLevel(index, newLevel) {
            regularPlayers[index].level = newLevel;
            renderRegularPlayers();
            saveRatings(); // Auto-save when level changes
        }

        // Toggle player attendance
        function toggleRegularAttendance(index) {
            regularPlayers[index].checked = !regularPlayers[index].checked;
        }

        // Render regular players list
        function renderRegularPlayers() {
            const container = document.getElementById('regular-players-list');
            
            if (regularPlayers.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;"><strong>No regular players loaded yet.</strong><br><br>Click the "Load Regular Players" button above to load the 23 default players (Allan Dale Ho, Allyza Magsino Ramos, etc.)<br><br>After loading, their star ratings will be saved for future use!</p>';
                return;
            }
            
            container.innerHTML = '';
            
            regularPlayers.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'regular-player-item';
                
                // Create stars display
                const starsHTML = Array(3).fill(0).map((_, i) => 
                    `<span style="opacity: ${i < player.level ? '1' : '0.3'}" onclick="toggleRegularLevel(${index}, ${i + 1})">‚≠ê</span>`
                ).join('');
                
                item.innerHTML = `
                    <input type="checkbox" ${player.checked ? 'checked' : ''} onchange="toggleRegularAttendance(${index})">
                    <span class="regular-player-name">${player.name}</span>
                    <div class="regular-player-stars">
                        ${starsHTML}
                    </div>
                    <button class="regular-remove-btn" onclick="removeRegularPlayer(${index})">Remove</button>
                `;
                
                container.appendChild(item);
            });
        }

        // Select all regular players
        function selectAllRegulars() {
            if (regularPlayers.length === 0) {
                alert('No regular players loaded. Click "Load Regular Players" first!');
                return;
            }
            
            // Check if all are already selected
            const allSelected = regularPlayers.every(p => p.checked);
            
            // Toggle: if all selected, unselect all; otherwise select all
            regularPlayers.forEach(player => {
                player.checked = !allSelected;
            });
            
            renderRegularPlayers();
        }

        // Auto-populate selected players to main columns
        function autoPopulatePlayers() {
            const selectedPlayers = regularPlayers.filter(p => p.checked);
            
            if (selectedPlayers.length === 0) {
                alert('Please select players by checking their checkboxes!');
                return;
            }
            
            // Clear current players
            players.beginner = [];
            players.intermediate = [];
            players.advanced = [];
            
            // Add selected players to appropriate levels
            selectedPlayers.forEach(player => {
                const levelMap = {
                    1: 'beginner',
                    2: 'intermediate',
                    3: 'advanced'
                };
                
                const level = levelMap[player.level];
                if (level) {
                    players[level].push(player.name);
                }
            });
            
            // Render all columns
            ['beginner', 'intermediate', 'advanced'].forEach(level => {
                renderPlayers(level);
            });
            
            alert(`${selectedPlayers.length} players added to their respective skill levels!`);
        }

        // Save entire regular players list to localStorage
        function saveRegularPlayers() {
            localStorage.setItem('badmintonShufflerPlayers', JSON.stringify(regularPlayers));
        }

        // Load saved regular players from localStorage
        function loadSavedRegularPlayers() {
            const saved = localStorage.getItem('badmintonShufflerPlayers');
            return saved ? JSON.parse(saved) : null;
        }

        // Save ratings to localStorage (legacy support)
        function saveRatings() {
            saveRegularPlayers(); // Now saves entire list
        }

        // Load saved ratings from localStorage (legacy support)
        function loadSavedRatings() {
            const players = loadSavedRegularPlayers();
            if (players) {
                const ratings = {};
                players.forEach(p => ratings[p.name] = p.level);
                return ratings;
            }
            return {};
        }
        
        // Toggle visibility of player columns section
        function togglePlayerSection() {
            const section = document.getElementById('player-columns-section');
            if (section.style.display === 'none') {
                section.style.display = 'grid';
            } else {
                section.style.display = 'none';
            }
        }
        
        // Toggle visibility of regular players section
        function toggleRegularSection() {
            const section = document.getElementById('regular-players-section');
            if (section.style.display === 'none') {
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
        }

        // Store generated rounds and game type globally
        let generatedRounds = [];
        let currentGameType = '';
        
        // Print all courts with all their rounds
        function printAllCourts() {
            if (generatedRounds.length === 0) {
                alert('Please generate teams first!');
                return;
            }
            
            // Find all unique court numbers
            const courtNumbers = new Set();
            generatedRounds.forEach(round => {
                round.courts.forEach(court => {
                    courtNumbers.add(court.number);
                });
            });
            
            const sortedCourts = Array.from(courtNumbers).sort((a, b) => a - b);
            
            // Determine game type title
            const gameTypeTitle = currentGameType === 'level' ? 'Level Game' : 'Mix Game';
            
            // Create print window
            const printWindow = window.open('', '', 'height=600,width=800');
            
            printWindow.document.write('<html><head><title>Badminton Schedule - ' + gameTypeTitle + '</title>');
            printWindow.document.write('<style>');
            printWindow.document.write(`
                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    padding: 40px;
                    background: white;
                }
                h1 {
                    text-align: center;
                    color: #1a5632;
                    margin-bottom: 40px;
                    font-size: 2em;
                }
                .mini-floor-plan {
                    display: grid;
                    grid-template-columns: repeat(3, 1fr);
                    gap: 3px;
                    width: 120px;
                    margin-left: 15px;
                    padding: 8px;
                    background: #f8f9fa;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    flex-shrink: 0;
                }
                .mini-court-box {
                    aspect-ratio: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: #e9ecef;
                    border: 1px solid #ccc;
                    border-radius: 3px;
                    font-weight: bold;
                    font-size: 0.75em;
                    color: #999;
                    padding: 2px;
                }
                .mini-court-box.active {
                    background: #1a5632;
                    color: #d4af37;
                    border-color: #d4af37;
                    border-width: 2px;
                }
                .court-section {
                    margin-bottom: 40px;
                    page-break-inside: avoid;
                }
                .court-header-container {
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    margin-bottom: 20px;
                }
                .court-header {
                    font-size: 1.5em;
                    font-weight: bold;
                    color: #d4af37;
                    padding: 12px;
                    background: #1a5632;
                    border-radius: 8px;
                    flex: 1;
                }
                .game {
                    margin-bottom: 15px;
                    padding: 12px;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    background: #f8f9fa;
                }
                .round-label {
                    font-weight: bold;
                    color: #1a5632;
                    margin-bottom: 8px;
                }
                .match-line {
                    margin: 5px 0;
                    font-size: 0.95em;
                }
                .player-name {
                    padding: 2px 6px;
                    border-radius: 3px;
                    display: inline-block;
                    margin: 1px;
                }
                .player-name.beginner {
                    background: #A8C5A3;
                    color: white;
                }
                .player-name.intermediate {
                    background: #738A6E;
                    color: white;
                }
                .player-name.advanced {
                    background: #344C3D;
                    color: white;
                }
            `);
            printWindow.document.write('</style></head><body>');
            
            // Write header with logo
            printWindow.document.write('<div style="text-align: center; margin-bottom: 30px;">');
            printWindow.document.write('<img src="North Smashers.png" alt="North Smashers Logo" style="max-width: 150px; height: auto; margin-bottom: 15px;" onerror="this.onerror=null; this.src=\'North Smashers.jpg\';">');
            printWindow.document.write('<h1 style="color: #1a5632; margin: 0;">üè∏ Badminton Schedule - ' + gameTypeTitle + '</h1>');
            printWindow.document.write('</div>');
            
            // Helper function to generate mini floor plan
            function generateMiniFloorPlan(activePhysicalCourt) {
                const courtLayout = [
                    [10, 11, 12],
                    [7, 8, 9],
                    [4, 5, 6],
                    [1, 2, 3]
                ];
                
                let html = '<div class="mini-floor-plan">';
                courtLayout.forEach(row => {
                    row.forEach(physicalNum => {
                        const isActive = physicalNum === activePhysicalCourt;
                        const activeClass = isActive ? 'active' : '';
                        html += '<div class="mini-court-box ' + activeClass + '">' + physicalNum + '</div>';
                    });
                });
                html += '</div>';
                return html;
            }
            
            // For each court, show all its rounds
            sortedCourts.forEach(courtNum => {
                // Get physical court number for this court (same for all rounds)
                const physicalCourt = getPhysicalCourtNumber(courtNum);
                
                printWindow.document.write('<div class="court-section">');
                
                // Court header with floor plan
                printWindow.document.write('<div class="court-header-container">');
                printWindow.document.write('<div class="court-header">Court ' + courtNum + '</div>');
                printWindow.document.write(generateMiniFloorPlan(physicalCourt));
                printWindow.document.write('</div>');
                
                // All rounds for this court
                generatedRounds.forEach(round => {
                    const court = round.courts.find(c => c.number === courtNum);
                    if (court) {
                        printWindow.document.write('<div class="game">');
                        printWindow.document.write('<div class="round-label">Round ' + round.number + '</div>');
                        
                        // Team 1
                        printWindow.document.write('<div class="match-line">');
                        court.team1.forEach(p => {
                            printWindow.document.write('<span class="player-name ' + p.level + '">' + p.name + '</span> ');
                        });
                        printWindow.document.write(' <strong>vs</strong> ');
                        
                        // Team 2
                        court.team2.forEach(p => {
                            printWindow.document.write('<span class="player-name ' + p.level + '">' + p.name + '</span> ');
                        });
                        printWindow.document.write('</div>');
                        printWindow.document.write('</div>');
                    }
                });
                
                printWindow.document.write('</div>');
            });
            
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            
            setTimeout(() => {
                printWindow.print();
            }, 250);
        }
        
        // Print all rounds for a specific court
        function printCourt(roundNum, courtNum) {
            // Create a temporary container for printing
            const printWindow = window.open('', '', 'height=600,width=800');
            
            printWindow.document.write('<html><head><title>Court ' + courtNum + ' Schedule</title>');
            printWindow.document.write('<style>');
            printWindow.document.write(`
                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    padding: 40px;
                    background: white;
                }
                h1 {
                    text-align: center;
                    color: #1a5632;
                    margin-bottom: 30px;
                }
                .court-header {
                    text-align: center;
                    font-size: 1.8em;
                    font-weight: bold;
                    color: #333;
                    margin-bottom: 30px;
                    padding: 15px;
                    background: #f8f9fa;
                    border-radius: 10px;
                }
                .round-section {
                    margin-bottom: 25px;
                    padding: 20px;
                    border: 2px solid #1a5632;
                    border-radius: 10px;
                    page-break-inside: avoid;
                }
                .round-title {
                    font-size: 1.3em;
                    font-weight: bold;
                    color: #1a5632;
                    margin-bottom: 15px;
                }
                .match {
                    padding: 15px;
                    background: #f8f9fa;
                    border-radius: 8px;
                    margin-bottom: 10px;
                }
                .team {
                    margin: 8px 0;
                }
                .team-label {
                    font-weight: bold;
                    color: #333;
                    margin-bottom: 5px;
                }
                .vs {
                    text-align: center;
                    font-weight: bold;
                    color: #d4af37;
                    margin: 10px 0;
                }
                .player-name {
                    padding: 3px 8px;
                    border-radius: 3px;
                    display: inline-block;
                    margin: 2px;
                }
                .player-name.beginner {
                    background: #A8C5A3;
                    color: white;
                }
                .player-name.intermediate {
                    background: #738A6E;
                    color: white;
                }
                .player-name.advanced {
                    background: #344C3D;
                    color: white;
                }
            `);
            printWindow.document.write('</style></head><body>');
            
            // Write header with logo
            printWindow.document.write('<div style="text-align: center; margin-bottom: 30px;">');
            printWindow.document.write('<img src="North Smashers.png" alt="North Smashers Logo" style="max-width: 150px; height: auto; margin-bottom: 15px;" onerror="this.onerror=null; this.src=\'North Smashers.jpg\';">');
            printWindow.document.write('<h1 style="color: #1a5632; margin: 0;">üè∏ Badminton Schedule</h1>');
            printWindow.document.write('</div>');
            printWindow.document.write('<div class="court-header">Court ' + courtNum + '</div>');
            
            // Find all matches for this court across all rounds
            generatedRounds.forEach(round => {
                const court = round.courts.find(c => c.number === courtNum);
                if (court) {
                    printWindow.document.write('<div class="round-section">');
                    printWindow.document.write('<div class="round-title">Round ' + round.number + '</div>');
                    printWindow.document.write('<div class="match">');
                    
                    // Team 1
                    printWindow.document.write('<div class="team">');
                    printWindow.document.write('<div class="team-label">Team 1:</div>');
                    court.team1.forEach(p => {
                        printWindow.document.write('<span class="player-name ' + p.level + '">' + p.name + '</span> ');
                    });
                    printWindow.document.write('</div>');
                    
                    // VS
                    printWindow.document.write('<div class="vs">VS</div>');
                    
                    // Team 2
                    printWindow.document.write('<div class="team">');
                    printWindow.document.write('<div class="team-label">Team 2:</div>');
                    court.team2.forEach(p => {
                        printWindow.document.write('<span class="player-name ' + p.level + '">' + p.name + '</span> ');
                    });
                    printWindow.document.write('</div>');
                    
                    printWindow.document.write('</div></div>');
                }
            });
            
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            
            // Wait a bit for content to load, then print
            setTimeout(() => {
                printWindow.print();
            }, 250);
        }

        // ===== PLAYER SWAP FUNCTIONALITY =====
        
        let swapMode = {
            active: false,
            round: null,
            court: null,
            team: null,
            index: null,
            isSitting: false
        };

        // Start swap from a playing player
        function startSwap(roundNum, courtNum, teamNum, playerIndex) {
            // If already in swap mode, cancel it
            if (swapMode.active) {
                cancelSwap();
                return;
            }

            swapMode = {
                active: true,
                round: roundNum,
                court: courtNum,
                team: teamNum,
                index: playerIndex,
                isSitting: false
            };

            // Highlight the selected player
            const allPlayers = document.querySelectorAll('.player-name');
            allPlayers.forEach(el => {
                const elRound = parseInt(el.dataset.round);
                const elCourt = el.dataset.court ? parseInt(el.dataset.court) : null;
                const elTeam = el.dataset.team ? parseInt(el.dataset.team) : null;
                const elIndex = parseInt(el.dataset.index);
                const elSitting = el.dataset.sitting === 'true';

                // Mark the selected player
                if (elRound === roundNum && elCourt === courtNum && elTeam === teamNum && elIndex === playerIndex) {
                    el.classList.add('swap-mode');
                }
                // Mark sitting out players as swap targets
                else if (elRound === roundNum && elSitting) {
                    el.classList.add('swap-target');
                    el.onclick = () => executeSwap(elRound, null, null, elIndex, true);
                }
            });
        }

        // Start swap from a sitting out player
        function startSwapFromSitting(roundNum, sittingIndex) {
            // If already in swap mode, cancel it
            if (swapMode.active) {
                cancelSwap();
                return;
            }

            swapMode = {
                active: true,
                round: roundNum,
                court: null,
                team: null,
                index: sittingIndex,
                isSitting: true
            };

            // Highlight the selected player
            const allPlayers = document.querySelectorAll('.player-name');
            allPlayers.forEach(el => {
                const elRound = parseInt(el.dataset.round);
                const elCourt = el.dataset.court ? parseInt(el.dataset.court) : null;
                const elTeam = el.dataset.team ? parseInt(el.dataset.team) : null;
                const elIndex = parseInt(el.dataset.index);
                const elSitting = el.dataset.sitting === 'true';

                // Mark the selected player
                if (elRound === roundNum && elSitting && elIndex === sittingIndex) {
                    el.classList.add('swap-mode');
                }
                // Mark playing players as swap targets
                else if (elRound === roundNum && !elSitting) {
                    el.classList.add('swap-target');
                    el.onclick = () => executeSwap(elRound, elCourt, elTeam, elIndex, false);
                }
            });
        }

        // Execute the swap
        function executeSwap(targetRound, targetCourt, targetTeam, targetIndex, targetIsSitting) {
            const round = generatedRounds[swapMode.round - 1];
            
            // Get source player
            let sourcePlayer;
            if (swapMode.isSitting) {
                sourcePlayer = round.sittingOut[swapMode.index];
            } else {
                const sourceCourt = round.courts.find(c => c.number === swapMode.court);
                sourcePlayer = swapMode.team === 1 ? sourceCourt.team1[swapMode.index] : sourceCourt.team2[swapMode.index];
            }

            // Get target player
            let targetPlayer;
            if (targetIsSitting) {
                targetPlayer = round.sittingOut[targetIndex];
            } else {
                const targetCourtObj = round.courts.find(c => c.number === targetCourt);
                targetPlayer = targetTeam === 1 ? targetCourtObj.team1[targetIndex] : targetCourtObj.team2[targetIndex];
            }

            // Perform the swap
            if (swapMode.isSitting && !targetIsSitting) {
                // Swap: sitting out -> playing
                round.sittingOut[swapMode.index] = targetPlayer;
                const targetCourtObj = round.courts.find(c => c.number === targetCourt);
                if (targetTeam === 1) {
                    targetCourtObj.team1[targetIndex] = sourcePlayer;
                } else {
                    targetCourtObj.team2[targetIndex] = sourcePlayer;
                }
            } else if (!swapMode.isSitting && targetIsSitting) {
                // Swap: playing -> sitting out
                const sourceCourt = round.courts.find(c => c.number === swapMode.court);
                if (swapMode.team === 1) {
                    sourceCourt.team1[swapMode.index] = targetPlayer;
                } else {
                    sourceCourt.team2[swapMode.index] = targetPlayer;
                }
                round.sittingOut[targetIndex] = sourcePlayer;
            } else if (!swapMode.isSitting && !targetIsSitting) {
                // Swap: playing <-> playing
                const sourceCourt = round.courts.find(c => c.number === swapMode.court);
                const targetCourtObj = round.courts.find(c => c.number === targetCourt);
                
                if (swapMode.team === 1) {
                    sourceCourt.team1[swapMode.index] = targetPlayer;
                } else {
                    sourceCourt.team2[swapMode.index] = targetPlayer;
                }
                
                if (targetTeam === 1) {
                    targetCourtObj.team1[targetIndex] = sourcePlayer;
                } else {
                    targetCourtObj.team2[targetIndex] = sourcePlayer;
                }
            }

            // Refresh display
            displayResults(generatedRounds);
            cancelSwap();
        }

        // Cancel swap mode
        function cancelSwap() {
            swapMode = {
                active: false,
                round: null,
                court: null,
                team: null,
                index: null,
                isSitting: false
            };

            // Remove all highlighting
            document.querySelectorAll('.player-name').forEach(el => {
                el.classList.remove('swap-mode', 'swap-target');
                el.onclick = null;
            });
        }

        // ===== DRAG AND DROP FUNCTIONALITY =====
        
        let draggedPlayer = null;

        function handleDragStart(e) {
            draggedPlayer = {
                round: parseInt(e.target.dataset.round),
                court: e.target.dataset.court ? parseInt(e.target.dataset.court) : null,
                team: e.target.dataset.team ? parseInt(e.target.dataset.team) : null,
                index: parseInt(e.target.dataset.index),
                isSitting: e.target.dataset.sitting === 'true'
            };
            
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Only allow drop if it's a different player in the same round
            const targetRound = parseInt(e.target.dataset.round);
            if (draggedPlayer && targetRound === draggedPlayer.round) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetRound = parseInt(e.target.dataset.round);
            const targetCourt = e.target.dataset.court ? parseInt(e.target.dataset.court) : null;
            const targetTeam = e.target.dataset.team ? parseInt(e.target.dataset.team) : null;
            const targetIndex = parseInt(e.target.dataset.index);
            const targetIsSitting = e.target.dataset.sitting === 'true';

            // Only swap if same round and different players
            if (draggedPlayer && targetRound === draggedPlayer.round) {
                if (draggedPlayer.isSitting !== targetIsSitting || 
                    draggedPlayer.court !== targetCourt || 
                    draggedPlayer.team !== targetTeam || 
                    draggedPlayer.index !== targetIndex) {
                    
                    const round = generatedRounds[draggedPlayer.round - 1];
                    
                    // Get source and target players
                    let sourcePlayer, targetPlayer;
                    
                    if (draggedPlayer.isSitting) {
                        sourcePlayer = round.sittingOut[draggedPlayer.index];
                    } else {
                        const sourceCourt = round.courts.find(c => c.number === draggedPlayer.court);
                        sourcePlayer = draggedPlayer.team === 1 ? sourceCourt.team1[draggedPlayer.index] : sourceCourt.team2[draggedPlayer.index];
                    }
                    
                    if (targetIsSitting) {
                        targetPlayer = round.sittingOut[targetIndex];
                    } else {
                        const targetCourtObj = round.courts.find(c => c.number === targetCourt);
                        targetPlayer = targetTeam === 1 ? targetCourtObj.team1[targetIndex] : targetCourtObj.team2[targetIndex];
                    }
                    
                    // Perform swap
                    if (draggedPlayer.isSitting && !targetIsSitting) {
                        round.sittingOut[draggedPlayer.index] = targetPlayer;
                        const targetCourtObj = round.courts.find(c => c.number === targetCourt);
                        if (targetTeam === 1) {
                            targetCourtObj.team1[targetIndex] = sourcePlayer;
                        } else {
                            targetCourtObj.team2[targetIndex] = sourcePlayer;
                        }
                    } else if (!draggedPlayer.isSitting && targetIsSitting) {
                        const sourceCourt = round.courts.find(c => c.number === draggedPlayer.court);
                        if (draggedPlayer.team === 1) {
                            sourceCourt.team1[draggedPlayer.index] = targetPlayer;
                        } else {
                            sourceCourt.team2[draggedPlayer.index] = targetPlayer;
                        }
                        round.sittingOut[targetIndex] = sourcePlayer;
                    } else if (!draggedPlayer.isSitting && !targetIsSitting) {
                        const sourceCourt = round.courts.find(c => c.number === draggedPlayer.court);
                        const targetCourtObj = round.courts.find(c => c.number === targetCourt);
                        
                        if (draggedPlayer.team === 1) {
                            sourceCourt.team1[draggedPlayer.index] = targetPlayer;
                        } else {
                            sourceCourt.team2[draggedPlayer.index] = targetPlayer;
                        }
                        
                        if (targetTeam === 1) {
                            targetCourtObj.team1[targetIndex] = sourcePlayer;
                        } else {
                            targetCourtObj.team2[targetIndex] = sourcePlayer;
                        }
                    }
                    
                    // Refresh display
                    displayResults(generatedRounds);
                }
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.player-name').forEach(el => {
                el.classList.remove('drag-over');
            });
            draggedPlayer = null;
        }

        // ===== DARK MODE FUNCTIONALITY =====
        
        // Toggle dark mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            
            // Update button icon
            const toggleBtn = document.getElementById('dark-mode-toggle');
            toggleBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            
            // Save preference
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        }
        
        // Load dark mode preference
        function loadDarkModePreference() {
            const darkMode = localStorage.getItem('darkMode');
            if (darkMode === 'enabled') {
                document.body.classList.add('dark-mode');
                document.getElementById('dark-mode-toggle').textContent = '‚òÄÔ∏è';
            }
        }
        
        // Initialize star selector on page load
        updateNewRegularStars();
        
        // Load dark mode preference on page load
        loadDarkModePreference();
        
        // Auto-load saved regular players if they exist in localStorage
        window.addEventListener('load', () => {
            const savedPlayers = loadSavedRegularPlayers();
            if (savedPlayers && savedPlayers.length > 0) {
                // Load the entire saved list (including custom players)
                regularPlayers = savedPlayers.map(p => ({
                    ...p,
                    checked: false // Reset checked status
                }));
                
                // Migrate old name to new name
                regularPlayers.forEach(player => {
                    if (player.name === "Chesca Chia-Vivas") {
                        player.name = "Chesca Chua-Vivas";
                    }
                });
                
                renderRegularPlayers();
                saveRegularPlayers(); // Save with corrected name
            } else {
                // First time user - auto-load default regular players
                regularPlayers = defaultRegularPlayers.map(name => ({
                    name: name,
                    level: 2, // Default to intermediate
                    checked: false
                }));
                renderRegularPlayers();
                saveRegularPlayers(); // Save for future use
            }
        });

        // ===== COURT FLOOR PLAN SELECTION =====
        
        // Array to track selected courts in order: [{physical: 10, sequence: 1}, {physical: 3, sequence: 2}, ...]
        let selectedCourts = [];
        
        // Toggle court selection
        function toggleCourtSelection(physicalNum) {
            // Check if this court is already selected
            const existingIndex = selectedCourts.findIndex(c => c.physical === physicalNum);
            
            if (existingIndex !== -1) {
                // Court is already selected - remove it and renumber
                selectedCourts.splice(existingIndex, 1);
                
                // Renumber remaining courts
                selectedCourts.forEach((court, idx) => {
                    court.sequence = idx + 1;
                });
            } else {
                // Add new court with next sequence number
                selectedCourts.push({
                    physical: physicalNum,
                    sequence: selectedCourts.length + 1
                });
            }
            
            // Update visual display
            updateCourtSelectionDisplay();
            
            // Update the court count field
            document.getElementById('court-count').value = selectedCourts.length;
        }
        
        // Update the visual display of court selections
        function updateCourtSelectionDisplay() {
            document.querySelectorAll('.court-box').forEach(box => {
                const physicalNum = parseInt(box.dataset.physical);
                const courtData = selectedCourts.find(c => c.physical === physicalNum);
                
                if (courtData) {
                    // This court is selected
                    box.classList.add('selected');
                    const sequenceLabel = box.querySelector('.sequence-num');
                    if (sequenceLabel) {
                        sequenceLabel.textContent = `C${courtData.sequence}`;
                    }
                } else {
                    // This court is not selected
                    box.classList.remove('selected');
                }
            });
        }
        
        // Get the physical court number for a given sequence number
        function getPhysicalCourtNumber(sequenceNum) {
            const court = selectedCourts.find(c => c.sequence === sequenceNum);
            return court ? court.physical : sequenceNum; // Fallback to sequence if not found
        }
    </script>
</body>
</html>
